<?php

namespace Thinbus;

/*
 * Copyright 2014 Ruslan Zavacky <ruslan.zavackiy@gmail.com>
 * Copyright 2015-2017 Simon Massey
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
use Math_BigInteger;

class ThinbusSrpCommon {
    
    /**
     * @var string The user identity 'I'.
     */
    protected $userID;
    
    protected $salt;
    
    /**
     * Get Precision
     *
     * @return number The number of bits which can hold the internal binary represention of the number.
     * @access public
     */
    public function getPrecision($bi) {
        $bits = $bi->toBytes();
        $temp = ord($bits[0]);
        // figures out how many bits to shift left the first byte to make it zero
        for ($i = 0; $temp >> $i; ++$i);
        // assignes 8 bits for all bytes appart fro the first byte where we know the exact bits
        $precision = 8 * strlen($bits) - 8 + $i;
        return $precision;
    }

    public function stripLeadingZeros($str)
    {
        return ltrim($str, '0');
    }
    
    public function binary2hex($string)
    {
        $chars = array(
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            'a',
            'b',
            'c',
            'd',
            'e',
            'f'
        );
    
        $length = strlen($string);
    
        $result = '';
        for ($i = 0; $i < $length; $i ++) {
            $b = ord($string[$i]);
            $result = $result . $chars[($b & 0xF0) >> 4];
            $result = $result . $chars[$b & 0x0F];
        }
    
        return $result;
    }
    
    /**
     *
     * @param number $bytes
     *            The number of secure bytes. Defaults to 32 which is 256 bits.
     * @return string
     */
    public function getSecureRandom($bytes = 32)
    {
        $str = random_bytes($bytes);
        return $this->binary2hex($str);
    }
    
    /**
     * Generates a random SRP-6a client or server private value ('a' or
     * 'b') which is in the range [1,N-1] generated by a random number of
     * at least 256 bits.
     * 
     * It also adds `H(I+":"+salt+":"+time())` to the generated random number. This ensures 
     * that even with a totally fault random number generator a different value will be 
     * used at each login attempt.  
     *
     * <p>Specification: RFC 5054.
     */
    public function createRandomBigIntegerInRange($n)
    {
        $precisionN = $this->getPrecision($n);
    
        $minBits = max(array(
            256,
            $precisionN
        ));
    
        $ZERO = new Math_BigInteger("0", 10);
        $ONE = new Math_BigInteger("1", 10);
    
        $r = $ZERO;
    
        while ($r->equals($ZERO)) {
            $x = new Math_BigInteger($this->getSecureRandom(1 + $minBits / 8), 16);
            
            $oneTime = $this->hash($this->userID.":".$this->salt.':'.time().microtime());
            $oneTimeBi = new Math_BigInteger($oneTime, 16);
            $x = $x->add($oneTimeBi);
            
            $r = $x->modPow($ONE, $n);
        }
    
        return $r;
    }
    
}
